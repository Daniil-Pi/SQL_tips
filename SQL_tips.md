```markdown
# SQL Основные конструкции и операторы

## Основная конструкция SELECT
```sql
SELECT столбец, другой_столбец, …
FROM моя_таблица;
```

---

## Конструкция SELECT с условием WHERE
```sql
SELECT столбец, другой_столбец, …
FROM моя_таблица
WHERE условие
    AND/OR другое_условие
    AND/OR …;
```

---

## Числовые операторы
| Оператор                  | Описание                                          | Пример                     |
|---------------------------|---------------------------------------------------|----------------------------|
| `=, !=, <, <=, >, >=`     | Стандартные числовые операторы                    | `col_name != 4`            |
| `BETWEEN … AND …`         | Число в диапазоне (включая границы)               | `col_name BETWEEN 1.5 AND 10.5` |
| `NOT BETWEEN … AND …`     | Число вне диапазона (включая границы)             | `col_name NOT BETWEEN 1 AND 10` |
| `IN (…)`                  | Число существует в списке                         | `col_name IN (2, 4, 6)`    |
| `NOT IN (…)`              | Число не существует в списке                      | `col_name NOT IN (1, 3, 5)` |

---

## Строковые операторы
| Оператор                  | Описание                                          | Пример                     |
|---------------------------|---------------------------------------------------|----------------------------|
| `=`                       | Точное сравнение строк **с учётом регистра**      | `col_name = "abc"`         |
| `!=` или `<>`             | Неравенство строк **с учётом регистра**           | `col_name != "abcd"`       |
| `LIKE`                    | Сравнение строк **без учёта регистра**            | `col_name LIKE "ABC"`      |
| `NOT LIKE`                | Неравенство строк **без учёта регистра**          | `col_name NOT LIKE "ABCD"` |
| `%`                       | Замена последовательности символов (0 или более)  | `col_name LIKE "%AT%"`<br>(совпадения: "AT", "ATTIC", "CAT") |
| `_`                       | Замена одного символа                             | `col_name LIKE "AN_"`<br>(совпадение: "AND", но не "AN") |
| `IN (…)`                  | Строка существует в списке                        | `col_name IN ("A", "B", "C")` |
| `NOT IN (…)`              | Строка не существует в списке                     | `col_name NOT IN ("D", "E", "F")` |


## Сортировка результатов (ORDER BY)
```sql
SELECT столбец, другой_столбец, …
FROM моя_таблица
WHERE условия
ORDER BY столбец ASC/DESC;
```
- **ORDER BY** — сортировка результатов по указанному столбцу
- **ASC** — по возрастанию (по умолчанию)
- **DESC** — по убыванию

---

## Выбор уникальных значений (DISTINCT)
```sql
SELECT DISTINCT столбец, другой_столбец, …
FROM моя_таблица
WHERE условия;
```


### Пояснение:
- **DISTINCT** — возвращает только уникальные комбинации значений для указанных столбцов
- Применяется ко **всем** перечисленным столбцам в SELECT
- Если указан один столбец — вернет уникальные значения этого столбца
- Если указано несколько столбцов — вернет уникальные комбинации этих столбцов

---

### Примеры использования
1. Получить список уникальных городов клиентов:
```sql
SELECT DISTINCT город 
FROM клиенты;
```

2. Найти уникальные пары "город + страна":
```sql
SELECT DISTINCT город, страна 
FROM клиенты;
```

3. Уникальные товары определенной категории:
```sql
SELECT DISTINCT название_товара 
FROM товары
WHERE категория = 'Электроника';
```

---

### Важные нюансы
1. **Производительность:** DISTINCT требует сортировки данных, что может замедлять запросы на больших таблицах
2. **NULL-значения:** DISTINCT считает все NULL-значения одинаковыми (вернет только одно NULL-значение, даже если их несколько)
3. **Сортировка:** Для упорядочивания уникальных значений используйте комбинацию с ORDER BY:
```sql
SELECT DISTINCT город 
FROM клиенты
ORDER BY город ASC;
```

---

## Ограничение вывода (LIMIT + OFFSET)
```sql
SELECT столбец, другой_столбец, …
FROM моя_таблица
WHERE условия
ORDER BY столбец ASC/DESC
LIMIT num_limit OFFSET num_offset;
```
| Оператор       | Описание                          | Пример                     |
|----------------|-----------------------------------|----------------------------|
| **LIMIT N**    | Возвращает только N первых строк  | `LIMIT 5` → первые 5 строк |
| **OFFSET M**   | Пропускает первые M строк         | `OFFSET 3` → пропустить 3 строки |
| **Комбинация** | Пагинация результатов             | `LIMIT 10 OFFSET 20` → строки 21-30 |

---

### Примеры использования
1. Получить 5 самых дорогих товаров:
```sql
SELECT название, цена 
FROM товары
ORDER BY цена DESC
LIMIT 5;
```

2. Показать товары 6-10 из отсортированного списка:
```sql
SELECT название, цена 
FROM товары
ORDER BY цена ASC
LIMIT 5 OFFSET 5;
```

3. Сортировка по нескольким столбцам:
```sql
SELECT имя, фамилия, зарплата 
FROM сотрудники
ORDER BY зарплата DESC, фамилия ASC;
``` 

---

### Важные нюансы
1. **Порядок операторов:** Сначала `WHERE`, затем `ORDER BY`, в конце `LIMIT/OFFSET`
2. **OFFSET без LIMIT** — не работает в большинстве СУБД
3. **Производительность:** Используйте индексы для столбцов в `ORDER BY`

---

## Запрос с INNER JOIN для нескольких таблиц

```sql
SELECT 
    столбец, 
    столбец_из_другой_таблицы, 
    …
FROM 
    моя_таблица
INNER JOIN другая_таблица 
    ON моя_таблица.id = другая_таблица.id  -- Условие соединения
WHERE 
    условия_фильтрации                    -- Фильтрация данных
ORDER BY 
    столбец, … ASC/DESC                   -- Сортировка
LIMIT 
    num_limit                             -- Ограничение количества строк
OFFSET 
    num_offset;                           -- Смещение (пагинация)

SELECT 
    column, 
    another_column, 
    …
FROM 
    mytable
    INNER/LEFT/RIGHT/FULL JOIN another_table 
        ON mytable.id = another_table.matching_id
WHERE 
    condition(s)
ORDER BY 
    column, … ASC/DESC
LIMIT 
    num_limit 
OFFSET 
    num_offset;
```
## IS NULL и IS NOT NULL

```sql
SELECT 
    column, 
    another_column, 
    …
FROM 
    mytable
WHERE 
    column IS/IS NOT NULL
    AND/OR another_condition
    AND/OR …;
```

### **Пояснение:**

  - **`IS NULL`**: Выбирает строки, где значение столбца равно `NULL`.
  - **`IS NOT NULL`**: Выбирает строки, где значение столбца не равно `NULL`.

## Псевдонимы AS
```sql
SELECT 
    column AS better_column_name, 
    …
FROM 
    a_long_widgets_table_name AS mywidgets
INNER JOIN 
    widget_sales
ON 
    mywidgets.id = widget_sales.widget_id;
```

---

### **Пояснение:**
- **`SELECT`**: Список столбцов для вывода. Используется `AS` для присвоения столбцу псевдонима (`better_column_name`).
- **`FROM`**: Основная таблица. Используется `AS` для присвоения таблице псевдонима (`mywidgets`).

---

### **Функции агрегации:**

| Функция                  | Описание                                                                 |
|--------------------------|-------------------------------------------------------------------------|
| `COUNT(*)`, `COUNT(column)` | Часто используемая функция для подсчета количества строк в группе. Если имя столбца не указано, считает все строки. Если указано, считает строки с не-NULL значениями в указанном столбце. |
| `MIN(column)`             | Находит наименьшее числовое значение в указанном столбце для всех строк в группе. |
| `MAX(column)`             | Находит наибольшее числовое значение в указанном столбце для всех строк в группе. |
| `AVG(column)`             | Находит среднее числовое значение в указанном столбце для всех строк в группе. |
| `SUM(column)`             | Находит сумму всех числовых значений в указанном столбце для строк в группе. |

---

### **Пример SQL-запроса с агрегацией:**

```sql
SELECT 
    AGG_FUNC(column_or_expression) AS aggregate_description, 
    …
FROM 
    mytable
WHERE 
    constraint_expression
GROUP BY 
    column;
```

---

### **Пояснение:**
- **`AGG_FUNC`**: Агрегатная функция (например, `COUNT`, `MIN`, `MAX`, `AVG`, `SUM`).
- **`AS aggregate_description`**: Псевдоним для результата агрегатной функции.

---

Вот переработанные SQL-запросы в формате Markdown:

---

### **Пример очередности запросов:**

```sql
SELECT DISTINCT 
    column, 
    AGG_FUNC(column_or_expression), 
    …
FROM 
    mytable
    JOIN another_table
      ON mytable.column = another_table.column
WHERE 
    constraint_expression
GROUP BY 
    column
HAVING 
    constraint_expression
ORDER BY 
    column ASC/DESC
LIMIT 
    count 
OFFSET 
    COUNT;
```

---

### **Пояснение:**
- **`SELECT`**: Выбор столбцов или выражений.
- **`DISTINCT`**: Удаление дубликатов.
- **`AGG_FUNC`**: Агрегатная функция (например, `COUNT`, `SUM`, `AVG`).
- **`FROM`**: Указание таблицы.
- **`JOIN`**: Соединение таблиц по условию.
- **`WHERE`**: Фильтрация строк.
- **`GROUP BY`**: Группировка данных.
- **`HAVING`**: Фильтрация групп.
- **`ORDER BY`**: Сортировка результатов.
- **`LIMIT`**: Ограничение количества строк.
- **`OFFSET`**: Пропуск строк перед выводом.

---

Вот переработанный текст в формате Markdown с переведенными описаниями на русский язык:

```markdown
# Порядок выполнения SQL-запросов

1. **FROM и JOIN**
   Сначала выполняется предложение `FROM` и последующие `JOIN`, чтобы определить общий рабочий набор данных, который будет обрабатываться. Это включает подзапросы в данном предложении и может привести к созданию временных таблиц, содержащих все столбцы и строки объединяемых таблиц.

2. **WHERE**
   После получения общего рабочего набора данных применяются условия `WHERE` к каждой строке. Строки, которые не удовлетворяют условиям, отбрасываются. Каждое из условий может обращаться только к столбцам непосредственно из таблиц, указанных в `FROM`. Алиасы из части `SELECT` запроса недоступны на этом этапе, так как они могут зависеть от частей запроса, которые еще не выполнены.

3. **GROUP BY**
   Оставшиеся строки после применения условий `WHERE` группируются по общим значениям в столбце, указанном в `GROUP BY`. В результате группировки остается столько строк, сколько уникальных значений в этом столбце. Это подразумевает, что `GROUP BY` следует использовать только при наличии агрегатных функций в запросе.

4. **HAVING**
   Если в запросе есть `GROUP BY`, то условия `HAVING` применяются к сгруппированным строкам, отбрасывая те, которые не удовлетворяют условиям. Как и в `WHERE`, алиасы также недоступны на этом этапе в большинстве баз данных.

5. **SELECT**
   На этом этапе вычисляются все выражения, указанные в части `SELECT` запроса.

6. **DISTINCT**
   Из оставшихся строк отбрасываются те, которые имеют дублирующиеся значения в столбце, помеченном как `DISTINCT`.

7. **ORDER BY**
   Если указан порядок сортировки с помощью `ORDER BY`, строки сортируются по указанным данным в порядке возрастания или убывания. Поскольку все выражения в `SELECT` уже вычислены, можно ссылаться на алиасы в этом предложении.

8. **LIMIT / OFFSET**
   Наконец, строки, которые выходят за пределы диапазона, указанного `LIMIT` и `OFFSET`, отбрасываются, оставляя окончательный набор строк для возврата из запроса.
``` 

### INSERT

```sql
INSERT INTO mytable
    (column, another_column, …)
VALUES
    (value_or_expr, another_value_or_expr, …),
    (value_or_expr_2, another_value_or_expr_2, …),
    …;
```

### Пояснение:
- `mytable` — имя таблицы, в которую вставляются данные.
- `(column, another_column, …)` — список колонок, в которые будут добавлены значения.
- `VALUES` — ключевое слово, после которого перечисляются строки данных.
- Каждая строка данных заключается в круглые скобки `(…)`, а значения разделяются запятыми.
- Строки данных также разделяются запятыми.

Пример с конкретными значениями:

```sql
INSERT INTO users
    (id, name, age)
VALUES
    (1, 'Alice', 25),
    (2, 'Bob', 30),
    (3, 'Charlie', 22);
``` 
### UPDATE
```sql
UPDATE mytable
SET 
    column = value_or_expr, 
    other_column = another_value_or_expr, 
    …
WHERE 
    condition;
```

### Пояснение:
- **`UPDATE mytable`** — указывает таблицу, в которой нужно обновить данные.
- **`SET`** — задает новые значения для столбцов.
- **`column = value_or_expr`** — обновление значения столбца на указанное значение или выражение.
- **`WHERE condition`** — условие, которое определяет, какие строки будут обновлены. Если условие не указано, обновятся все строки в таблице.


### DELETE

```sql
DELETE FROM mytable
WHERE 
    condition;
```

### Пояснение:
- **`DELETE FROM mytable`** — указывает таблицу, из которой нужно удалить данные.
- **`WHERE condition`** — условие, которое определяет, какие строки будут удалены. **Важно**: если условие не указано, удалятся **все строки** в таблице.

### Пример использования:
```sql
DELETE FROM employees
WHERE 
    department = 'IT' AND salary < 60000;
```

Этот запрос удалит всех сотрудников из отдела `IT` с зарплатой меньше 60000.

## Базы данных
Есть "физические" таблицы, которые хранятся в своих базах данных, то есть занимают постоянное место на диске, имеют вот такой вид названия - [адрес сервера].имя_базы_данных.название_схемы.название_таблицы, например, DataMart.dbo.Organization.
DataMart - БД
dbo - схема
Organization - таблица

Если запрос выполняется на том же серваке, где и находится таблица, то прописывать сервак не нужно.


А вот временные таблицы имеют вид #название_времянки и хранятся всегда в базе tmpdb (это системная БД). Хранятся эти времянки в tmpdb до тех пор, пока у тебя открыта сессия(окно), после закрытия удаляются, поэтому постоянного места не занимают.
В основном используются для промежуточных выгрузок данных, которые понадобятся в дальнейшем в скрипте

# Оконные функции

Оконные функции в T-SQL — это мощный инструмент для анализа данных **без группировки строк** в итоговый результат. Они работают с "окном" данных, которое определяется через оператор `OVER()`, отсюда и название. Давайте разберемся детально.

---

### **Что такое оконные функции?**
Это функции, которые выполняют вычисления над набором строк, связанных с **текущей строкой** (например: нумерация, ранжирование, агрегация). Они:
- Не схлопывают строки, как `GROUP BY`.
- Сохраняют все исходные строки в выводе.
- Работают с "окном" данных, заданным через `PARTITION BY` и `ORDER BY`.

---

### **Функция `ROW_NUMBER()`**
**Что делает:** Присваивает уникальный номер каждой строке в рамках заданного окна.

**Пример:**
```sql
SELECT 
  Name, 
  Salary,
  ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RowNum
FROM Employees;
```
**Результат:**
| Name   | Salary | RowNum |
|--------|--------|--------|
| Alice  | 90000  | 1      |
| Bob    | 80000  | 2      |
| Carol  | 80000  | 3      |
| Dave   | 70000  | 4      |

**Особенности:**
- Номера уникальны, даже если значения в `ORDER BY` совпадают (Carol получила 3, а не 2).
- Без `ORDER BY` в `OVER()` вы получите ошибку.

---

### **Основные виды оконных функций**

#### 1. **Ранжирующие функции**
- **`ROW_NUMBER()`** — сквозная нумерация строк.
- **`RANK()`** — ранжирование с пропуском номеров при совпадении.
  ```sql
  SELECT 
    Name, 
    Salary,
    RANK() OVER (ORDER BY Salary DESC) AS Rank
  FROM Employees;
  ```
  | Name   | Salary | Rank |
  |--------|--------|------|
  | Alice  | 90000  | 1    |
  | Bob    | 80000  | 2    |
  | Carol  | 80000  | 2    |
  | Dave   | 70000  | 4    | -- Пропущен номер 3!

- **`DENSE_RANK()`** — ранжирование без пропуска номеров.
  ```sql
  DENSE_RANK() OVER (ORDER BY Salary DESC) AS DenseRank
  ```
  | Name   | Salary | DenseRank |
  |--------|--------|-----------|
  | Alice  | 90000  | 1         |
  | Bob    | 80000  | 2         |
  | Carol  | 80000  | 2         |
  | Dave   | 70000  | 3         | -- Нет пропуска!

- **`NTILE(n)`** — разбивает результат на `n` групп.
  ```sql
  NTILE(4) OVER (ORDER BY Salary DESC) AS Quartile
  ```

---

#### 2. **Агрегатные функции как оконные**
Любая агрегатная функция (`SUM`, `AVG`, `MIN`, `MAX`, `COUNT`) может работать как оконная:
```sql
SELECT 
  OrderDate,
  Total,
  SUM(Total) OVER (ORDER BY OrderDate) AS RunningTotal
FROM Orders;
```
**Результат:**
| OrderDate  | Total | RunningTotal |
|------------|-------|--------------|
| 2023-01-01 | 100   | 100          |
| 2023-01-02 | 200   | 300          |
| 2023-01-03 | 150   | 450          |

---

#### 3. **Функции смещения**
- **`LAG()`** — доступ к предыдущей строке.
- **`LEAD()`** — доступ к следующей строке.
- **`FIRST_VALUE()`** — первое значение в окне.
- **`LAST_VALUE()`** — последнее значение в окне.

**Пример:**
```sql
SELECT 
  OrderDate,
  Total,
  LAG(Total) OVER (ORDER BY OrderDate) AS PrevTotal
FROM Orders;
```
| OrderDate  | Total | PrevTotal |
|------------|-------|-----------|
| 2023-01-01 | 100   | NULL      |
| 2023-01-02 | 200   | 100       |
| 2023-01-03 | 150   | 200       |

---

### **Ключевые части `OVER()`**
Оконные функции всегда включают `OVER()`, который определяет **окно данных**:

1. **`PARTITION BY`** — разбивает данные на группы (аналог `GROUP BY`, но без схлопывания строк).
   ```sql
   ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC)
   ```
   Нумерация зарплат внутри каждого отдела.

2. **`ORDER BY`** — задает порядок строк в окне (обязателен для `ROW_NUMBER`, `RANK`, `DENSE_RANK`).

3. **`ROWS/RANGE`** — ограничивает окно физическими (`ROWS`) или логическими (`RANGE`) границами:
   ```sql
   SUM(Total) OVER (ORDER BY OrderDate ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
   ```
   Сумма текущей и предыдущей строки.

---

### **Почему называются "оконными"?**
Потому что они работают с "окном" — подмножеством строк, определенным через:
- `PARTITION BY` (горизонтальное разбиение),
- `ORDER BY` (вертикальное упорядочивание),
- `ROWS/RANGE` (границы окна).

---

### **Примеры использования**
1. **Топ-N записей в каждой группе:**
```sql
WITH Ranked AS (
  SELECT 
    Name, 
    DepartmentID,
    Salary,
    ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS Rank
  FROM Employees
)
SELECT * FROM Ranked WHERE Rank <= 3;
```

2. **Сравнение текущей строки с предыдущей:**
```sql
SELECT 
  OrderDate,
  Total,
  Total - LAG(Total) OVER (ORDER BY OrderDate) AS Diff
FROM Orders;
```

3. **Вычисление нарастающего итога:**
```sql
SELECT 
  OrderDate,
  Total,
  SUM(Total) OVER (ORDER BY OrderDate) AS CumulativeSum
FROM Orders;
```

---

### **Итог**
- **Оконные функции** позволяют выполнять сложные аналитические запросы без джойнов и подзапросов.
- **`ROW_NUMBER()`** — простейшая функция для нумерации строк.
- Ключевые элементы: `PARTITION BY`, `ORDER BY`, `ROWS/RANGE`.
- Используются для ранжирования, агрегации, сравнения строк и анализа трендов.

```
# Синтаксис CASE в T-SQL

## Базовая структура
### 1. Простой CASE (сравнение значения)
```sql
CASE выражение
    WHEN значение1 THEN результат1
    WHEN значение2 THEN результат2
    ...
    ELSE результат_по_умолчанию
END
```

### 2. Поисковый CASE (условия)
```sql
CASE
    WHEN условие1 THEN результат1
    WHEN условие2 THEN результат2
    ...
    ELSE результат_по_умолчанию
END
```

---

## Примеры использования
### В SELECT
```sql
SELECT 
    ProductName,
    CASE CategoryID
        WHEN 1 THEN 'Напитки'
        WHEN 2 THEN 'Молочные продукты'
        ELSE 'Другое'
    END AS Category
FROM Products;
```

### В WHERE
```sql
SELECT *
FROM Orders
WHERE 
    CASE 
        WHEN TotalAmount > 1000 THEN 1
        ELSE 0
    END = 1;
```

### В ORDER BY
```sql
SELECT *
FROM Employees
ORDER BY 
    CASE 
        WHEN Department = 'IT' THEN Salary
        ELSE Bonus 
    END DESC;
```

---

## Ключевые нюансы
- ✅ **Порядок проверки**: условия обрабатываются сверху вниз
- ✅ **ELSE**: необязателен (возвращает NULL, если не указан)
- ✅ **Типы данных**: все THEN должны быть совместимы
- ⚠️ **Лимит**: до 10 уровней вложенности

---

## Дополнительные возможности
### Вложенный CASE
```sql
CASE 
    WHEN Age < 18 THEN 'Ребенок'
    ELSE CASE 
            WHEN Age < 65 THEN 'Взрослый'
            ELSE 'Пенсионер'
         END
END
```

### В UPDATE
```sql
UPDATE Products
SET Price = CASE 
    WHEN Discount > 0 THEN Price * 0.9
    ELSE Price * 1.1
END;
```

---

[📌] Используйте CASE для:
- Преобразования данных "на лету"
- Условной агрегации
- Динамической сортировки
- Замены сложных JOIN для простых маппингов
```